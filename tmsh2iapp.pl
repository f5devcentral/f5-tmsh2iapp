#!/usr/bin/perl -w
#
# tmsh2iapp.pl - A tool for easily generating an iApp from an existing TMSH configuration using a TMSH-like template
#
#                The tool is also able to generate a HEAT template to instantiate this iApp in Openstack
#
###########################################################################################################################
# Copyright 2016 F5 Networks Inc 
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
###########################################################################################################################
#
# changelog:
#
# Ulises Alonso Camaro <u.alonsocamaro@f5.com>
#
# 2016/06/10 - u.alonsocamaro@f5.com - Initial version
# 2016/06/13 - u.alonsocamaro@f5.com - Embedding of TMSH configuration in the iApp and initial documentation
# 2016/06/14 - u.alonsocamaro@f5.com - FIX: when there is only one pool defined
# 2016/06/14 - u.alonsocamaro@f5.com - warn when pools are defined when using the "system" option
# 2016/06/14 - u.alonsocamaro@f5.com - FIX: do not create var section when there are no variables
# 2016/06/14 - u.alonsocamaro@f5.com - strings are now displayed with the xxlarge display hint
# 2016/06/23 - u.alonsocamaro@f5.com - Force the customer to use a full path when specifying the template
# 2016/06/24 - u.alonsocamaro@f5.com - Optionally allow labels and properties to variables, pool members and internal data-group records
# 2016/06/24 - u.alonsocamaro@f5.com - Allow dynamic number of records for internal data-groups
# 2016/06/24 - u.alonsocamaro@f5.com - pool_members_modify and data_records_modify now add code in the iApp to only modify the pool/data-group if the there are pool members/data records
# 2016/06/24 - u.alonsocamaro@f5.com - FIX: allow templates which contain fields with double quotes in them
# 2016/07/22 - u.alonsocamaro@f5.com - Removed app-service keyword from resulting iApp
# 2016/07/22 - u.alonsocamaro@f5.com - Introduced disable strict updates. Allows the generated iApp by modified. I needed this for a use-case. 
#                                      Note: This is a workaround until HEAT teampltes allow deploying iApps with strict updates disabled.
# 2016/09/20 - u.alonsocamaro@f5.com - Make conditional "disable strict updates" by making it a parameter. Also found that it doesn't work for "system" iApps so this is also a FIX.
# 2016/09/20 - u.alonsocamaro@f5.com - Usability improvements (hopefully :-):
#                                      + Full path of the template is no longer needed
#                                      + Now the resulting .cfg file which is load at iapp instantiation is stored in /var/tmp, this can be changed with the cfgdir variable
#                                      + Now the template file (input file of this utility) needs to have .tmpl extension
#                                      + Now the resulting iapp is not written to stdout but instead to a file in the same folder as the template but with the .iapp extension. 
# 2016/11/30 - u.alonsocamaro@f5.com - Added common and common-disable-strict-updates to allow creation of iApps that have objects in the /Common partition
#
# 2016/12/01 - u.alonsocamaro@f5.com - HEAT template creation preparation: iApp creation functions renamed with iapp_ prefix
# 2016/12/01 - u.alonsocamaro@f5.com - HEAT template creation preparation: function relocation
# 2016/12/01 - u.alonsocamaro@f5.com - HEAT template creation introduced
# 2016/12/07 - u.alonsocamaro@f5.com - Now the input file of this tool must have .t2i extension instead of .tmpl to avoid confusion because .tmpl is sometimes used with iApps. 
#                                      The iApps generated by this tool will continue having .iapp extension because it is unambiguous.
# 2017/04/18 - u.alonsocamaro@f5.com - Initial support for firewall address and port lists. heat-create needs to be updated.
# 2017/04/20 - u.alonsocamaro@f5.com - Assign empty strings to variables if these are not defined and assign them {} for proper substitution by string map
# 2017/04/24 - u.alonsocamaro@f5.com - Allow regular variables that have values separated by spaces
# 2017/04/28 - u.alonsocamaro@f5.com - Previous change makes the init_variables code not working well with empty values because they now become {}. That previous change on 2017/04/20 seems not useful any more. Commented out.
# 2017/05/23 - u.alonsocamaro@f5.com - Initial support for PEM URL categories in policy rules
# 2017/05/24 - u.alonsocamaro@f5.com - Some objects in the .t2i need to reference the iApp's instance folder, we make this folder available through a @service_folder token. This is only available when using the service and service-disable-strict-updates options.
# 2017/05/25 - u.alonsocamaro@f5.com - Introduction of @vartypes for simplifyling the script and making easier to extend for new var types
# 2017/05/25 - u.alonsocamaro@f5.com - Re-implemented heat-create using @vartypes
# 2017/05/25 - u.alonsocamaro@f5.com - Implementation of ansible-create
# 2017/06/09 - u.alonsocamaro@f5.com - Produced iApps are no longer have .iapp extension. Now .tmpl is used to follow the conventions.
# 2017/06/09 - u.alonsocamaro@f5.com - Implementation of iapp attributes, ie allowing the following to be specified:
#
#  description                 User defined description.
#  ignore-verification         Set to true to temporarily stop the verification of signature or checksum. Signature or checksum is still retained.
#  requires-bigip-version-max  Specifies the maximum version of BIG-IP required by this template.
#  requires-bigip-version-min  Specifies the minimum version of BIG-IP required by this template.
#  requires-modules            Adds, deletes, or replaces the list of modules that are required to be provisioned or enabled for this template to work.
#
# Example usage:
#
#  @iapp(description): "Creates a SIP load balancer"
#  @iapp(ignore-verification): true
#  @iapp(requires-bigip-version-min): 12.1.1 
#  @iapp(requires-modules): { ltm asm }
#
# Note that the syntax of the iApp attributes is the same of TMSH. 
#
# The iapp attribute unsupported-bigip-versions is an extension that is only applied to iWorkflow. The format is defined by iWorkflow:
#
#  @iapp(unsupported-bigip-versions): ["11.6.1", "12.0.1"]
#
# There is currently no support for signing or creating a checksum iApps.
#u  
# 2017/06/15 - u.alonsocamaro@f5.com - Implementation of iworkflow-json-apl and iworkflow-template-import
# 2017/06/15 - u.alonsocamaro@f5.com - version and usage options
# 2017/06/22 - u.alonsocamaro@f5.com - Support for iWorkflow variables __pool__addr__ and __pool__port__ for automatic statistics. See  https://devcentral.f5.com/wiki/iWorkflow.iWorkflowOpsGuide_v22_7.ashx
# 2017/06/27 - u.alonsocamaro@f5.com - iworkflow-template-import previously only created "service" iApps. Now any iApp type can be used. It depends in that template has been previously generated
# 2017/06/27 - u.alonsocamaro@f5.com - Introduction of pool member's properties without requiring additional variable types. Found some problems in tmsh and reported in C2469542/ID671372 and C2470063
# 2017/06/27 - u.alonsocamaro@f5.com - Fixed heat-create variable's template section curly braces
# 2017/06/27 - u.alonsocamaro@f5.com - Added starting/finished messages when the iApp is run
# 2017/06/27 - u.alonsocamaro@f5.com - @properties tag previously used for the presentation has been renamed to @apl for two reasons:
#                                      + allow easing migration to tmsh2iapp is migrated to iAppsLX
#                                      + @properties is a very generic tag and I might use it for other purposes later on
#
# 2017/06/28 - u.alonsocamaro@f5.com - Introduction of baseline .t2i generation. Usage:
#
#                                      tmsh2iapp snapshot-create <name of snapshot 1>
#                                      <Perform configuration with the GUI that is intended to be a standalone iApp>
#                                      tmsh2iapp snapshot-create <name of snapshot 2>
#
#                                      tmsh2iapp t2i-create <name of snapshot 1> <name of snapshot 2>
#
#                                      The snapshots are stored in /var/tmp and the resulting .t2i is stored in the same folder too with the name baseline-<snapshot 1>-<snapshot 2>.t2i
#
# 2017/07/11 - u.alonsocamaro@f5.com - pool__addr and pool__port are no longer mandated for iworkflow templates
# 2017/07/12 - u.alonsocamaro@f5.com - Removal support for per BIG-IP variables
# 2017/07/13 - u.alonsocamaro@f5.com - Introduction of importable objects, ie:
#
#                                      @import(ssl-cert): __cert1__ __cert2__ __cert3__
#                                      @import(ssl-crl): __crl1__
#                                      @import(ssl-csr): __csr1__ __csr2__
#                                      @import(ssl-key): __key1__ __key2__
#                                      @import(data-group): __dg1__
#                                      @import(external-monitor): __mon1__
#
# Where __<name>__ are variables in the .t2i file. The @import tag will create an additional automatic variable named __<name>_import__ where the URL from where to import the actual object to be imported. 
#
# This URL can be a local file (ie: file:///tmp/mycert.crt), a remote web server (ie: http://mywebserver.local.net/mycert.crt)  etc... any curl URL basically
#
# The types of objects that can be imported depend on the BIG-IP version, in this release up to v13 object types are supported:
#
#  apache-ssl-cert          SSL certificates management
#  browser-capabilities-db  browser capabilities DB file management
#  dashboard-viewset
#  data-group               External Data Group files management
#  device-capabilities-db   Device capabilities DB file management
#  external-monitor         External Monitor files management
#  ifile                    iFile files management
#  lwtunneltbl              LW4o6 table files management
#  ssl-cert                 SSL certificates management
#  ssl-crl                  SSL CRL files management
#  ssl-csr                  SSL Certificate Signing Request
#  ssl-key                  SSL certificate keys management
#
#  Note for data-group variables a @property(__<variable>__) attribute must be set, this is used to:
#
#  - specify the type of the records in the data-group (ie: string|integer|ip). This is mandatory.
#  - the separator used for the records. This is optional.
#
#  The syntax follows tmsh syntax, see the examples for more info.
#    
# Search for import_file_types and import_perl_types variables for implementation details. Main functions are attribute_import_type, iapp_implementation_import.
#
# 2017/07/17 - u.alonsocamaro@f5.com - preparation functions for @import(asm-policy)
# 2017/07/17 - u.alonsocamaro@f5.com - All foreach loops on variable's arrays have been sorted 
# 2017/07/18 - u.alonsocamaro@f5.com - Initial support of LTM policies
#
#                                      Didn't find a way of loading them with tmsh::load hence these will be created with tmsh::create which requires extracting 
#                                      the relevant section of the .t2i file. The load of the .t2i is now done incrementally.
#
# 2017/07/20 - u.alonsocamaro@f5.com - Initial support of ASM policies, they don't work yet unless using already imported policies. Researching this issue.
# 2017/07/21 - u.alonsocamaro@f5.com - Support comments within the .t2i file by using the # symbol
# 2017/07/21 - u.alonsocamaro@f5.com - Made more relaxed the usage of @ and #. They can have spaces from the beginning of the line now. They must match ^\s*(@|#)
# 2017/07/31 - u.alonsocamaro@f5.com - Added check_variable_names to avoid mistake of using hyphen in variable names
# 2017/08/01 - u.alonsocamaro@f5.com - FIX: @service_folder can now be really placed anywhere
# 2017/08/02 - u.alonsocamaro@f5.com - FIX: @service_folder can now be really placed anywhere (part 2)
# 2017/08/02 - u.alonsocamaro@f5.com - FIX: incremental loader would previously fail if policy is at the top of the .t2i file 

$tmsh2iapp_version= "20170802.2";

# use strict;
binmode STDOUT, ":utf8";
use utf8;
use JSON;
use File::Basename;
use Text::Balanced qw (extract_codeblock);

$debug= 0;

sub check_iworkflow_variables;
sub check_variable_names;
sub attribute_import_type;

$cfgdir="/var/tmp";

if ($#ARGV == -1) {
    print_synopsis();
    exit 1;
}

if ($#ARGV == 0) {
    
    if ($ARGV[0] eq "version") {
	print_version();
	exit 0;
    } elsif ($ARGV[0] eq "usage") {
	print_usage();
	exit 0;
    } else {
	print STDERR "Wrong usage, check the possible options.\n";
	print_synopsis();
	exit 1;
    }
}

if (($#ARGV == 1) &&
    ($ARGV[0] ne "service") && 
    ($ARGV[0] ne "service-disable-strict-updates") &&
    ($ARGV[0] ne "common") &&
    ($ARGV[0] ne "common-disable-strict-updates") &&
    ($ARGV[0] ne "system") &&   
    ($ARGV[0] ne "heat-create") &&
    ($ARGV[0] ne "ansible-create") &&
    ($ARGV[0] ne "iworkflow-json-apl") &&
    ($ARGV[0] ne "iworkflow-template-import") &&
    ($ARGV[0] ne "snapshot-create")) {
    
    print STDERR "Wrong usage, check the possible options shown next\n\n";
    print_synopsis();
    exit 1;
}

if (($#ARGV == 1) && ($ARGV[0] eq "snapshot-create")) {

    check_this_is_bigip();
    make_snapshot($ARGV[1]);
    exit(0);
}

if (($#ARGV == 2) && ($ARGV[0] eq "t2i-create")) {

    check_this_is_bigip();
    diff_snapshots($ARGV[1], $ARGV[2]);
    exit(0);
}

if ($#ARGV >= 2) {
    print STDERR "Wrong usage, check the possible options shown next\n\n";
    print_synopsis();
    exit 1;
}


### From now on all the processing is for creating an output based on a .t2i file

if ($ARGV[0] eq "system") {
    $changepath='tmsh::cd "/"';
} elsif (($ARGV[0] eq "common") || ($ARGV[0] eq "common-disable-strict-updates")) {
    $changepath='tmsh::cd "/Common"';
} else {
    $changepath= "";
}

$t2i=$ARGV[1];

if (! ($t2i=~ m/\.t2i$/)) {
    
    print STDERR  "Wrong usage: the template file must have .t2i extension. See further details below.\n\n";
    print_synopsis();
    exit 1;
}

###

$iapp_name= basename($t2i);
# iApp name is basename without extension .t2i
$iapp_name=~ s/\.t2i$//;
# Resulting configuration file after template gets the variables replaced by their values
$cfgfile= $iapp_name . ".cfg";

# iApp output file name
$iapp_filename= $t2i;
$iapp_filename=~ s/\.t2i$/\.tmpl/;
$iapp_filename_relative= basename($iapp_filename);

# APL json output file name
$apl_filename= $t2i;
$apl_filename=~ s/\.t2i$/\.apl.json/;

# IMPORT json output file name
$import_filename= $t2i;
$import_filename=~ s/\.t2i$/\.import.json/;

###

open TMPL, "<", $t2i
    or die "Can't open template file $t2i: $!";

my $raw_content = do { local $/; <TMPL> };
close TMPL;

# Sanity checks

if (($ARGV[0] eq "system") && ($raw_content =~ /ltm pool/)) {
    
    print STDERR "Warning: pools should not be specified when the system option is used. This will trigger an error when assigning members to it\n";
}


# remove the attributes but not @service_folder
$content= join("\n", grep(!/^\s*(@(label|apl|properties|iapp|import)|\#)/, split(/\n/, $raw_content)));

# get the variables from the t2i file
my @matches = uniq ( $content =~ /(__pm__.+?__|__dr__.+?__|__fwal__.+?__|__fwpl__.+?__|__urlcat_match__.+?_.+?__|__urlcat_nomatch__.+?_.+?__|__pool__.+?__|__.+?__)/g );

check_variable_names(\@matches);
    
# we separate the items in arrays depending the type of variables. All have to be registered in the @vartypes array.

my @variables= grep(!/^(__pm|__dr|__fwal|__fwpl|__app_service__|__urlcat_match__|__urlcat_nomatch__|__pool__)/, @matches);
my @pool_members= grep(/^__pm/, @matches);
my @data_records= grep(/^__dr/, @matches);
my @fw_address_list= grep(/^__fwal/, @matches);
my @fw_port_list= grep(/^__fwpl/, @matches);
my @urlcat_match_list= grep(/^__urlcat_match/, @matches);
my @urlcat_nomatch_list= grep(/^__urlcat_nomatch/, @matches);
my @iworkflow_variables= grep(/^__pool/, @matches); # __pool__addr__ and __pool__port__ are currently a constrain to allow the iApp to expose stats automatically to iWorkflow
# check_iworkflow_variables(\@iworkflow_variables);

my @vartypes= (\@variables, \@pool_members, \@data_records, \@fw_address_list, \@fw_port_list, \@urlcat_match_list, \@urlcat_nomatch_list, \@iworkflow_variables);
my @vartypes_desc= ("General variables", "Pool members", "Internal data-group records", "Firewall address lists", "Firewall port lists", "PEM URL match category lists", "PEM URL no match category lists", "iWorkflow VIP address and VIP port variables");

my @import_file_types= ("apache-ssl-cert", "browser-capabilities-db", "dashboard-viewset", "data-group", "device-capabilities-db", "external-monitor", "ifile", "lwtunneltbl", "ssl-cert", "ssl-crl", "ssl-csr", "ssl-key", "asm-policy");
my @import_perl_types= @import_file_types;

# check if the template contains attributes, if so gather them...
my @attribute_lines= grep /^\s*@/, split(/\n/, $raw_content);

foreach $al (@attribute_lines) {
    
    $_= $al;
    
    if (/@(label|apl|properties|iapp|import)\((.*?)\):\s*(.*)/) {
	$attribute= $1;
	$variable= $2;
	$value= $3;
    } elsif (/\@service_folder/) {
	# Do nothing, service_folder can be anywhere
    } else {
	print STDERR "Aborting due to unexpected attribute line. The offending line is shown next: $al\n";
	exit(1);
    }
    
    if ($attribute eq "label") {
	$labels{$variable}= $value;
    } elsif ($attribute eq "apl") {
        $apl{$variable}= $value;
    } elsif ($attribute eq "properties") {
        check_legacy_properties_usage($variable, $value);
	$properties{$variable}= $value;
    } elsif ($attribute eq "iapp") {
	$iapp{$variable}= $value;
    } elsif ($attribute eq "import") {

	$arg= $variable; # rename it for clarity: in the case of @import the argument of is not a variable name

	attribute_import_type($arg, $value);
	    
    } else {
	# Given the check above this should never be triggered
	print STDERR "Aborting due to unknown attribute \"$attribute\" in the t2i template. The offending line is shown next: $al\n";
	exit(1);
    }
}

for my $i (0 .. $#import_file_types) { # the perl variables are the same as tmsh but we replace "-" with "_";

    $import_perl_types[$i]=~ s/-/_/g;
}


###################################################################################################
# Command to execute on the .t2i file

if ($ARGV[0] eq "heat-create") {
    
    heat_create();
    
} elsif ($ARGV[0] eq "ansible-create") {
    
    ansible_create();
    
} elsif ($ARGV[0] eq "iworkflow-json-apl") {
    
    iworkflow_json_apl(1);
    
} elsif ($ARGV[0] eq "iworkflow-template-import") {
    
    iworkflow_json_import();
    
} else {
    
    iapp_create(1);
}

exit 0;

###################################################################################################

sub iapp_create {
    
    my $create_file= $_[0];
    
    if ($create_file) {
	
        open IAPP, ">", $iapp_filename
            or die "Can't open file where the iApp would be written ($iapp_filename): $!";
    }
    
    $iapp= iapp_head();
    $iapp.= iapp_implementation_begin();
    $iapp.= iapp_implementation_procs();
    $iapp.= iapp_implementation_import();

    $iapp.= iapp_implementation_incremental_loader();
    
    $iapp.= iapp_implementation_pool_members_modify();
    $iapp.= iapp_implementation_data_records_modify();
    $iapp.= iapp_implementation_afm_address_list_modify();
    $iapp.= iapp_implementation_afm_port_list_modify();
    $iapp.= iapp_implementation_pem_urlcat_modify();
    
    if (($ARGV[0] eq "service-disable-strict-updates") || ($ARGV[0] eq "common-disable-strict-updates")) {
	
        $iapp.= iapp_implementation_disable_strict_updates();
    }
    
    $iapp.= iapp_implementation_end();
    $iapp.= iapp_presentation();
    $iapp.= iapp_tail();
    
    
    if ($create_file) {
	
        print IAPP $iapp; 
	
        close IAPP
	    or die "Couldn't close the file for the iApp ($iapp_filename): $!";
	
        print "Written the resulting iApp to $iapp_filename\n";
	
    } else {
	
	return $iapp;
    }
}

sub iapp_head {
    
    my $head = <<"HEAD";
cli admin-partitions {
    update-partition Common
}

sys application template $iapp_name {

    actions {
        definition {
HEAD
    
    return $head;
}

sub iapp_implementation_begin {
    
    my $implementation_begin= << "IMPLEMENTATION_BEGIN";

            implementation {

		puts "Starting iApp \$tmsh::app_name.app generated with tmsh2iapp version $tmsh2iapp_version"

IMPLEMENTATION_BEGIN
    
    return $implementation_begin;
}

sub iapp_implementation_procs {

    my $implementation_proc_debug= << "IMPLEMENTATION_PROC_DEBUG";

# Modified from appsvcs_integration_v2.0.tmpl

# Print a timestamped debug message to /var/tmp/scriptd.out
# Input: headers = TCL list of headers for the log message
#        msg = The message to log
#        level = Integer indicated the log level for this message
proc debug { headers msg level } {
    set systemTime [clock seconds]
    set brackets ""
    if { [llength \$headers] > 0 } {
      set brackets [format "\\[%s\\]" [join \$headers "\\]\\["]]
    }
    set pre [format "\\[%s %s\\]\\[%s\\]%s" [clock format \$systemTime -format %D] [clock format \$systemTime -format %H:%M:%S] \$::tmsh::app_name.app \$brackets]
    puts [format "%s %s" \$pre [string map [list "\n" "\n\$pre " ] \$msg]]
}

IMPLEMENTATION_PROC_DEBUG

    my $implementation_proc_curl_save_file= << "IMPLEMENTATION_PROC_CURL_SAVE_FILE";

# Modified from appsvcs_integration_v2.0.tmpl to support local files as well

# Run the cURL command and save the URL to a file.  Throws a hard error if cURL
# exits uncleanly
# Input: string url = URL to fetch
#        string filename = filename to save output to
#        int error_exit = 1 => throw hard error on non 200 response code
#                         >1 => ignore error and return response code
proc curl_save_file { url filename {error_exit 1}} {
  debug [list curl_save_file start] "url=\$url filename=\$filename error_exit=\$error_exit" 9
  set status [catch {
    exec curl --connect-timeout 5 -k -s -w 'RESPCODE=\%\{response_code\}' -o \$filename \$url
  } message]

  debug [list curl_save_file done] "status=\$status message=\$message" 9

  if { \$status != 0 } {
    if { \$error_exit == 1} {
      error "Error occured while trying to retrieve \$url (status \$status): \$message"
    } else {
        return 0
    }
  }

  return 1
}

IMPLEMENTATION_PROC_CURL_SAVE_FILE

    $check_import_type= "asm_policy"; # To avoid the following warning Name "main::asm_policy" used only once: possible typo at ./tmsh2iapp.pl line 477.
    if (@$check_import_type) {
	
	return $implementation_proc_debug . $implementation_proc_curl_save_file;
    }
    
    return "";
}

sub iapp_implementation_import {
    
    my $import= "";
    my $import_type;
    my $import_otype;

    foreach $import_type (sort @import_perl_types) {
	
	foreach $var (sort @$import_type) {
	    
	    $import_otype= $import_type;
	    $import_otype=~ s/_/-/g;
	    
	    $vname= $var;
	    $vname=~ s/__(.*?)__/var__$1/;
	    
	    $url= $var;
	    $url=~ s/__(.*?)__/var__$1_import/;
	    
	    if ($import_otype eq "data-group") {
		$import.= "                tmsh::create sys file $import_otype \${::$vname} source-path \${::$url} $properties{$var}\n";
	    } elsif ($import_otype eq "asm-policy") {
		$import.= "                curl_save_file \${::$url} $cfgdir/\${::$vname}.xml\n";
		$import.= "                tmsh::load asm policy \${::$vname} file $cfgdir/\${::$vname}.xml overwrite\n";
		$import.= "                tmsh::modify asm policy \${::$vname} active\n";

	    } else {
		$import.= "                tmsh::create sys file $import_otype \${::$vname} source-path \${::$url}\n";
	    }

	}
    }
    
    $import.= "\n";
    
    return $import;
}

sub iapp_implementation_variables_instantiation {
    
    $map= "";
    
    # tmsh2iapp defined variables
    
    if (($ARGV[0] eq "service") || ($ARGV[0] eq "service-disable-strict-updates")) {
	
	$map.= "\@service_folder \$tmsh::app_name.app ";
    }
    
    # Plain iApp variables
    
    foreach $v (sort @variables) {
	
	$vname= $v;
	$vname=~ s/__(.*?)__/var__$1/;
	
	$map.= "$v {\${::$vname}} ";
    }
    
    # The next variables are list types and are replaced with "" or with a default value and a _modify function will instantiate them later    
    foreach $pm (sort @pool_members) {
	
	$map.= "$pm {} ";
    }
    
    foreach $dr (sort @data_records) {
	
	$map.= "$dr {} ";
    }
    
    foreach $fwal (sort @fw_address_list) {
        # Unfortunatly it doesn't allow an empty value
        $map.= "$fwal 255.255.255.255/32 ";
    }
    
    foreach $fwpl (sort @fw_port_list) {
        # Unfortunately it doesn't allow an tmpty value
        $map.= "$fwpl 65535 ";
    }
    
    foreach $urlcat (sort @urlcat_match_list) {
        $map.= "$urlcat {} ";
    }
    
    foreach $urlcat (sort @urlcat_nomatch_list) {
        $map.= "$urlcat {} ";
    }
    
    foreach $iwork (sort @iworkflow_variables) {
	
        $vname= $iwork;
        $vname=~ s/__(.*)__/$1/;
	
        $map.= "$iwork {\${::$vname}} ";
    }
    
    # app-service
    $full_app_service= "\$tmsh::app_name" . ".app" . "/" . "\$tmsh::app_name";
    $map.= "__app_service__ $full_app_service ";
    
    # build the return value
    
    $retval= "";
    $retval= $retval . "                set cfg [string map \"$map\" \$cfg]\n"; 
    return $retval;
}

sub iapp_implementation_config_load_section {

    $_= $_[0];
    if (m/^\s*$/) {
        print STDERR "load_section: No content in section: \n$_[0]\n" if ($debug);
        return "";
    } else {
	print STDERR "load_section: content found in section: \n$_[0]\n" if ($debug);
    }

    my $vars_instantiation= iapp_implementation_variables_instantiation();

    my $txt = << "CFG";

                set cfg { $_[0] }
CFG

    my $load_cmd = <<"LOAD_CMD";

                set fileId [open $cfgdir/$cfgfile "w"]
                puts -nonewline \$fileId \$cfg
                close \$fileId

                $changepath
                tmsh::load sys config merge file $cfgdir/$cfgfile
LOAD_CMD

    return $txt . $vars_instantiation . $load_cmd;
}

sub iapp_implementation_create_ltm_policy {

    my $retval= "";
    my $policy= $_[0];

    $policy=~ s/\n//g;
    $policy=~ s/\s+/ /g;
    $policy=~ s/ltm policy ((\w+|-|_)+)/ltm policy $1 legacy/;
    
    $policy=~ s/actions/actions replace-all-with/g;
    $policy=~ s/controls/controls replace-all-with/g;
    $policy=~ s/conditions/conditions replace-all-with/g;
    $policy=~ s/requires/requires replace-all-with/g;
    $policy=~ s/rules/rules replace-all-with/g;
    $policy=~ s/{(.*)}/$1/g;

    # instantiate variables in the policy, this should be moved to a function eventually

    my $map= "";
    
    if (($ARGV[0] eq "service") || ($ARGV[0] eq "service-disable-strict-updates")) {
	
	$map.= "\@service_folder \$tmsh::app_name.app ";
    }

    foreach $v (sort @variables) {
	
	$vname= $v;
	$vname=~ s/__(.*?)__/var__$1/;
	
	$map.= "$v {\${::$vname}} ";
    }

    $full_app_service= "\$tmsh::app_name" . ".app" . "/" . "\$tmsh::app_name";
    $map.= "__app_service__ $full_app_service ";
    
    # build the return value
    
    $retval = "                set policy [string map \"$map\" {$policy}]\n";
    $retval.= "                puts \"\$policy\"\n";
    $retval.= "                tmsh::create \$policy\n";
    
    return $retval;
}

sub iapp_implementation_incremental_loader {

    @lines= split /^/, $content;
    $remaining= $content;
    my $retval= "";
    
    $i= 0;

    while($i < scalar(@lines)) {

	$_= $lines[$i];
	
	if (/^\s*ltm policy/) {

	    @prev= @lines[0..$i-1];
	    @next= @lines[$i..scalar(@lines)-1];
	    
	    $prev_flat= join("", @prev);
	    $next_flat= join("", @next);
	    
	    print STDERR ">>> prev_flat:\n", $prev_flat, "\n" if ($debug);
	    print STDERR ">>> next_flat:\n", $next_flat, "\n" if ($debug);
	    
	    ($extracted, $remaining, $prefix)= extract_codeblock($next_flat, '{}', '^\s*ltm\s+policy\s+(\w+|-|_)+\s+');
	    $policy= $prefix . $extracted;

	    if (!defined($extracted)) {
		print STDERR "Aborting: could not match a valid ltm policy starting with the line $lines[$i]";
		exit(0);
	    }
	    
	    print STDERR ">>> extracted:\n", $extracted, "\n" if ($debug);
	    print STDERR ">>> remaining:\n", $remaining, "\n" if ($debug);

	    ###

	    $retval.= iapp_implementation_config_load_section($prev_flat) . "\n";
	    $retval.= iapp_implementation_create_ltm_policy($policy) . "\n";

	    ###
	    
	    $i= 0;
	    @lines= split /^/, $remaining;
	    
	    next;
	}
	
	$i= $i +1;
    }

    print STDERR ">>> remaining:\n", $remaining, "\n" if ($debug);
    $retval.= iapp_implementation_config_load_section($remaining);

    return $retval;
}

sub iapp_implementation_pool_members_modify {
    
    
    $tmsh_cmds= "\n\n";
    
    foreach $pm (sort @pool_members) {
	
	$pname= $pm; # pool name in the tmsh config
	$pname=~ s/__pm__(.*?)__/$1/;
	
	$vname= $pm; # var name in the iapp script
	$vname=~ s/__(.*)__/$1/;
	
	$vname_properties= $vname . "_properties";
	
	$tmsh_cmds.= "                if {([info exists {::$vname}]) && ([string length \${::$vname}] > 0)} {\n";
	$tmsh_cmds.= "                   set cmd \"tmsh::modify ltm pool $pname { members replace-all-with { \${::$vname} } }\"\n";
	$tmsh_cmds.= "                   puts \"\$cmd\"\n";
	$tmsh_cmds.= "                   eval \$cmd\n";
        $tmsh_cmds.= "                   if {([info exists {::$vname_properties}]) && ([string length \${::$vname_properties}] > 0)} {\n";
        $tmsh_cmds.= "                      set cmd \"tmsh::modify ltm pool $pname { members modify { all { \${::$vname_properties} } } }\"\n";
        $tmsh_cmds.= "                      puts \"\$cmd\"\n";
        $tmsh_cmds.= "                      eval \$cmd\n";
        $tmsh_cmds.= "                   }\n";
	$tmsh_cmds.= "                }\n";
	
    }
    
    return $tmsh_cmds;
}


sub iapp_implementation_data_records_modify {
    
    
    $tmsh_cmds= "\n\n";
    
    foreach $dr (sort @data_records) {
	
	$dname= $dr; # data group name in the tmsh config
	$dname=~ s/__dr__(.*?)__/$1/;
	
	$vname= $dr; # var name in the iapp script
	$vname=~ s/__(.*)__/$1/;
	
	$tmsh_cmds.= "                if {[string length \${::$vname}] > 0} {\n";
        # This is curious... tmsh modify from the cli doesn't require the extra brackets embracing the records parameter
	$tmsh_cmds.= "                   set cmd \"tmsh::modify ltm data-group internal $dname description $dname { records replace-all-with { \${::$vname} } }\"\n";
	
	$tmsh_cmds.= "                   puts \"\$cmd\"\n";
	$tmsh_cmds.= "                   eval \$cmd\n";
	$tmsh_cmds.= "                }\n";
    }
    
    return $tmsh_cmds;
}

sub iapp_implementation_afm_address_list_modify {
    
    
    $tmsh_cmds= "\n\n";
    
    foreach $fwal (sort @fw_address_list) {
	
        $fwal_name= $fwal; # firewall address list name in the tmsh config
        $fwal_name=~ s/__fwal__(.*?)__/$1/;
	
        $vname= $fwal; # var name in the iapp script
        $vname=~ s/__(.*)__/$1/;
	
        $tmsh_cmds.= "                if {[string length \${::$vname}] > 0} {\n";
        $tmsh_cmds.= "                   set cmd \"tmsh::modify security firewall address-list $fwal_name { addresses replace-all-with { \${::$vname} } }\"\n";
	
        $tmsh_cmds.= "                   puts \"\$cmd\"\n";
        $tmsh_cmds.= "                   eval \$cmd\n";
        $tmsh_cmds.= "                }\n";
    }
    
    return $tmsh_cmds;
}

sub iapp_implementation_afm_port_list_modify {
    
    
    $tmsh_cmds= "\n\n";
    
    foreach $fwpl (sort @fw_port_list) {
	
        $fwpl_name= $fwpl; # firewall port list name in the tmsh config
        $fwpl_name=~ s/__fwpl__(.*?)__/$1/;
	
        $vname= $fwpl; # var name in the iapp script
        $vname=~ s/__(.*)__/$1/;
	
        $tmsh_cmds.= "                if {[string length \${::$vname}] > 0} {\n";
        $tmsh_cmds.= "                   set cmd \"tmsh::modify security firewall port-list $fwpl_name { ports replace-all-with { \${::$vname} } }\"\n";
	
        $tmsh_cmds.= "                   puts \"\$cmd\"\n";
        $tmsh_cmds.= "                   eval \$cmd\n";
        $tmsh_cmds.= "                }\n";
    }
    
    return $tmsh_cmds;
}

sub iapp_implementation_pem_urlcat_modify {
    
    # match URL categories
    
    $tmsh_cmds= "\n\n";
    foreach $urlcat (sort @urlcat_match_list) {
	
        $policy_name= $urlcat; 
        $policy_name=~ s/__urlcat_match__(.*?)_(.*?)__/$1/;
	
        $rule_name= $urlcat;
        $rule_name=~ s/__urlcat_match__(.*?)_(.*?)__/$2/;
	
        $vname= $urlcat; # var name in the iapp script
        $vname=~ s/__(.*)__/$1/;
	
        $tmsh_cmds.= "                set urlcats [regexp -all -inline {\\S+} \${::$vname}]\n";
        $tmsh_cmds.= "                set urlcats [split \$urlcats]\n";
        $tmsh_cmds.= "                set i 0\n";
        $tmsh_cmds.= "                foreach cat \$urlcats {\n";
        # 
        # for some unknown funny reason tmsh::modify requires braces after rules and CLI tmsh doesn't:
        # root@(afm)(cfg-sync Standalone)(Active)(/Common)(tmos)# modify pem policy test.app/customfiltering rules { modify { filterurls { url-categorization-filters add { url_category0 { url-category Social_Networking operation match } } } } }
        # Syntax Error: "rules" unexpected argument "{" one of the following must be specified:
        # add, delete, modify, none, replace-all-with
        $tmsh_cmds.= "                   set cmd \"tmsh::modify pem policy $policy_name rules { modify { $rule_name { url-categorization-filters add { url_category\$i { url-category \$cat operation match } } } } }\"\n";
	
        $tmsh_cmds.= "                   puts \"\$cmd\"\n";
        $tmsh_cmds.= "                   eval \$cmd\n";
        $tmsh_cmds.= "                   incr i\n";
        $tmsh_cmds.= "                }\n";
    }
    
    
    # nomatch URL categories
    
    $tmsh_cmds.= "\n\n";
    foreach $urlcat (sort @urlcat_nomatch_list) {
	
        $policy_name= $urlcat;
        $policy_name=~ s/__urlcat_nomatch__(.*?)_(.*?)__/$1/;
	
        $rule_name= $urlcat;
        $rule_name=~ s/__urlcat_nomatch__(.*?)_(.*?)__/$2/;
	
        $vname= $urlcat; # var name in the iapp script
        $vname=~ s/__(.*)__/$1/;
	
        $tmsh_cmds.= "                set urlcats [regexp -all -inline {\\S+} \${::$vname}]\n";
        $tmsh_cmds.= "                set urlcats [split \$urlcats]\n";
        $tmsh_cmds.= "                set i 0\n";
        $tmsh_cmds.= "                foreach cat \$urlcats {\n";
        #
        # for some unknown funny reason tmsh::modify requires braces after rules and CLI tmsh doesn't:
        $tmsh_cmds.= "                   set cmd \"tmsh::modify pem policy $policy_name rules { modify { $rule_name { url-categorization-filters add { url_category\$i { url-category \$cat operation nomatch } } } } }\"\n";
	
        $tmsh_cmds.= "                   puts \"\$cmd\"\n";
        $tmsh_cmds.= "                   eval \$cmd\n";
        $tmsh_cmds.= "                   incr i\n";
        $tmsh_cmds.= "                }\n";
    }
    
    return $tmsh_cmds;
}

sub iapp_implementation_disable_strict_updates {
    
    $tmsh_cmds= "\n\n";
    
    if ($ARGV[0] eq "common-disable-strict-updates") {
	$service_path= "\$tmsh::app_name" . ".app" . "/" . "\$tmsh::app_name";
    } elsif ($ARGV[0] eq "service-disable-strict-updates") {
	$service_path= "\$tmsh::app_name";	
    }
    
    $tmsh_cmds.= "set cmd \"tmsh::modify sys application service $service_path strict-updates disabled\"\n";
    
    $tmsh_cmds.= "                   puts \"\$cmd\"\n";
    $tmsh_cmds.= "                   eval \$cmd\n";
    
    return $tmsh_cmds;
}

sub iapp_implementation_end {
    
    my $implementation_end  = << "IMPLEMENTATION_END";
    
                puts "Finished iApp \$tmsh::app_name.app generated with tmsh2iapp version $tmsh2iapp_version"
            }
IMPLEMENTATION_END
    
    return $implementation_end;
}

sub iapp_presentation {
    
    my $txt= << "TXT";
    
            presentation {

                include "/Common/f5.apl_common"
TXT
    
    ### variable definitions

    foreach $vartype (sort @vartypes) {
	
	@vt= @$vartype;
	
	if (($#vt +1) > 0) {
	    
	    $_= $vt[0];
	    
	    # vt_name = variable type name
	    if (/__(.+)__(.+)__/) {
		$vt_name= $1; # non plain variables type
	    } else {
		$vt_name= "var"; # plain variables type
	    }
	    
	    $txt= $txt . "                section $vt_name {\n";

	    foreach $v (sort @$vartype) {

		if (defined($apl{$v})) {
		    $p= $apl{$v};
		} else {
		    $p= "display \"xxlarge\"";
		}
		
		$vname= $v;
		$vname=~ s/__(.*__|)(.+)__/$2/;
		
		$txt= $txt . "                        string $vname $p\n";
		
		if ($vt_name eq "pm") { # Special processing for pm properties automatic variables
		    $vname_properties= $vname . "_properties";
		    $txt= $txt . "                        string $vname_properties $p\n";
		}
		
		if (defined($imports{$v})) { # Special processing for imported objects
		    $vname_import= $vname . "_import";
		    $txt= $txt . "                        string $vname_import display \"xxlarge\"\n";
		}
	    }
	    
	    $txt= $txt . "                }\n\n";
	}
    }
    
    ### Variables presentation
    
    $txt= $txt . "                text {\n";
    
    $i= 0;
    $vartype_plain= 1;
    
    foreach $vartype (sort @vartypes) {

	@vt= @$vartype;
	
	if (($#vt +1) > 0) {
	    
	    $_= $vt[0];
	    
	    # vt_name = variable type name
	    if (/__(.+)__(.+)__/) {
		$vt_name= $1; # non plain variables type
	    } else {
		$vt_name= "var"; # plain variables type
	    }

	    $txt= $txt . "\n                        $vt_name \"$vartypes_desc[$i]\"\n";

	    foreach $v (sort @$vartype) {

		if (defined($labels{$v})) {
		    $label= "$labels{$v}";
		} else {

		    # we append a __var prefix if it is plain var type
		    if ($vartype_plain == 1) {
			$prefix= "__var";
		    } else {
			$prefix= "";
		    }

		    $label= $prefix . $v;
		}

		$vname= $v;
		$vname=~ s/__(.*__|)(.+)__/$2/;

	        $txt= $txt . "                        $vt_name.$vname \"$label\"\n";
		
	        if ($vt_name eq "pm") { # Special processing for pm properties automatic variables
		    
		    $vname_properties= $vname . "_properties";
		    $label= "Properties for " . $label;
		    $txt= $txt . "                        $vt_name.$vname_properties \"$label\"\n"; 
	        }
		
		if (defined($imports{$v})) { # Special processing for imported objects
		    $vname_import= $vname . "_import";
		    $label= "URL for " . $label;
		    $txt= $txt . "                        $vt_name.$vname_import \"$label\"\n";
		}
		
	    }
	}
	
	$i= $i +1;
	$vartype_plain= 0;
    }
    
    ###
    
    my $presentation_end = << "PRESENTATION_END";
                }
            } 
PRESENTATION_END
    
    $txt= $txt . $presentation_end;

    return $txt;
}

sub iapp_tail {
    
    my $tail = <<"TAIL";
            role-acl { admin manager resource-admin }
        }
    }
TAIL
    
    foreach my $attr (sort keys %iapp) {
	if ($attr ne "unsupported-bigip-versions") {
	    $tail.= "    $attr $iapp{$attr}\n";
	}
    }
    
    $tail.= "\n}\n";
    
    return $tail;
}

### The next functions are for the heat_create option

sub heat_create {
    
    # HEAT output file names
    $heat_filename= $t2i;
    $heat_filename=~ s/\.t2i$/\.yaml/;
    $heat_params_filename= $t2i;
    $heat_params_filename=~ s/\.t2i$/\.parameters/;
    
    
    open HEAT, ">", $heat_filename
        or die "Can't open file where the HEAT template would be written ($heat_filename): $!";
    
    print HEAT heat_head();
    print HEAT heat_parameters();
    print HEAT heat_resources_static();
    print HEAT heat_resources_iapp_variables();
    
    close HEAT
        or die "Couldn't close the file for the HEAT template ($heat_filename): $!";
    
    print "Written the resulting HEAT template to $heat_filename\n";
    

    open HEAT_PARAMS, ">", $heat_params_filename
        or die "Can't open file where the HEAT parameters would be written ($heat_params_filename): $!";
    
    print HEAT_PARAMS heat_parameters_file();
    
    close HEAT_PARAMS
        or die "Couldn't close the file for the HEAT parameters ($heat_params_filename): $!";
    
    print "Written a sample HEAT parameters file for the HEAT template in $heat_params_filename\n";
}

sub heat_head {
    
    my $head = << "HEAD";

heat_template_version: 2015-04-30

description: HEAT deployer of iApp template $iapp_name


HEAD
    
    return $head;
}

sub heat_parameters {
    
    my $parameters = << "DEFAULT_PARAMS"; 

parameters:
  iapp_service_name:
    type: string
    label: iApp Service Name
    default: $iapp_name 
  ve_instance:
    type: string
    label:  BIG-IP's IP address
    description: Where the iApp will be deployed. Typically this is the IP address of the management interface
  bigip_un:
    type: string
    label: BigIP Login Username
    default: admin
  bigip_pw:
    type: string
    label: BigIP Login Password
    default: admin
DEFAULT_PARAMS
    
    foreach $vartype (sort @vartypes) {
	
	foreach $v (sort @$vartype) {
	    
	    $v_name= $v;
	    $v_name=~ s/__(.*)__/$1/;
	    
	    $parameters= $parameters . "  " . $v_name . ":\n";
	    $parameters= $parameters . "  " . "  " . "type: string\n";
	    
	    if (defined($labels{$v})) {
		$parameters= $parameters . "  " . "  " . "label: " . $labels{$v} . "\n";
	    } 
	    
	    $_= $v_name; # Special handling for pool members properties
	    if (/^pm__/) {
		
		$v_name_properties= $v_name . "_properties";
		
		$parameters= $parameters . "  " . $v_name_properties . ":\n";
		$parameters= $parameters . "  " . "  " . "type: string\n";
		
		if (defined($labels{$v})) {
		    $parameters= $parameters . "  " . "  " . "label: " . "Properties for " . $labels{$v} . "\n";
		}
            }

	    if (defined($imports{$v})) { # Special processing for imported objects
		$v_name_import= $v_name . "_import";

		$parameters= $parameters . "  " . $v_name_import . ":\n";
		$parameters= $parameters . "  " . "  " . "type: string\n";
		
		if (defined($labels{$v})) {
		    $parameters= $parameters . "  " . "  " . "label: " . "URL for " . $labels{$v} . "\n";
		}
		
	    }

	}
    }
    
    return $parameters;
}

sub heat_resources_static {
    
    my $resources = << "RESOURCES";
resources:
  bigip_rsrc:
    type: F5::BigIP::Device
    properties:
      ip: { get_param: ve_instance }
      username: { get_param: bigip_un }
      password: { get_param: bigip_pw }
  partition:
    type: F5::Sys::Partition
    depends_on: bigip_rsrc
    properties:
      name: Common
      bigip_server: { get_resource: bigip_rsrc }
  iapp_template:
    type: F5::Sys::iAppFullTemplate
    depends_on: [bigip_rsrc, partition]
    properties:
      bigip_server: { get_resource: bigip_rsrc }
      partition: { get_resource: partition }
      full_template: { get_file: $iapp_filename_relative }
  iapp_service:
    type: F5::Sys::iAppService
    depends_on: iapp_template
    properties:
      bigip_server: { get_resource: bigip_rsrc }
      partition: { get_resource: partition }
      traffic_group: none 
      name: { get_param: iapp_service_name }
      template_name: $iapp_name
RESOURCES
    
    return $resources;
}

sub heat_resources_iapp_variables {
    
    $vars_count= 0;
    
    foreach $vartype (sort @vartypes) {
	
	@vt= @$vartype;
	
	$vars_count+= ($#vt +1);
    }
    
    if ($vars_count == 0) {
	return "";
    }
    
    my $section= << "VARIABLES";
      variables: 
        str_replace:
          params:
VARIABLES
    
    foreach $vartype (sort @vartypes) {
	
	foreach $v (sort @$vartype) {
	    $v_name= $v;
	    $v_name=~ s/__(.*)__/$1/;
	    
	    $section.= "             " . "_" . $v_name . "_" . ":" . " { get_param: " . $v_name . " }\n";
	    
	    $_= $v_name; # Special handling for pool members properties
            if (/^pm__/) {
		
		$v_name_properties= $v_name . "_properties";
		$section.= "             " . "_" . $v_name_properties . "_" . ":" . " { get_param: " . $v_name_properties . " }\n";
            }

	    if (defined($imports{$v})) { # Special processing for imported objects
		$v_name_import= $v_name . "_import";
		$section.= "             " . "_" . $v_name_import . "_" . ":" . " { get_param: " . $v_name_import . " }\n";
	    }
	    
	}
    }
    
    $section.= "          template: |\n";
    $section.= "             [{\n";
    
    $vars_i= 1;
    $vartype_plain= 1;
    
    foreach $vartype (sort @vartypes) {
	
	# we append a var__ prefix if it is plain var type
	if ($vartype_plain == 1) {
	    $prefix= "var__";
	    $vartype_plain= 0;
	} else {
	    $prefix= "";
	}
	
	foreach $v (sort @$vartype) {
	    
	    $v_name= $v;
	    $v_name=~ s/__(.*)__/$1/;
	    
	    $section.= "                \"name\": " . "\"" . $prefix . $v_name . "\",\n";
	    $section.= "                \"encrypted\": \"no\",\n";
	    $section.= "                \"value\": " . "\"_" . $v_name . "_\"\n";
	    
            $_= $v_name;
            if (/^pm__/) { # Special processing for pool members
		
		$section.= "              }, {\n";
		
		$v_name_properties= $v_name . "_properties";
		
		$section.= "                \"name\": " . "\"" . $prefix . $v_name_properties . "\",\n";
		$section.= "                \"encrypted\": \"no\",\n";
		$section.= "                \"value\": " . "\"_" . $v_name_properties . "_\"\n";
            }


	    if (defined($imports{$v})) { # Special processing for imported objects

		$section.= "              }, {\n";
		
		$v_name_import= $v_name . "_import";
		
		$section.= "                \"name\": " . "\"" . $prefix . $v_name_import . "\",\n";
		$section.= "                \"encrypted\": \"no\",\n";
		$section.= "                \"value\": " . "\"_" . $v_name_import . "_\"\n";
	    }
	    
            if ($vars_i < $vars_count) {
		$section.= "              }, {\n";
            }
	    
            $vars_i= $vars_i +1;
	}
    }
    
    $section.= "              }]\n";
    
    return $section;
}

sub heat_parameters_file {
    
    my $default_params= << "DEFAULT_PARAMS";
parameters:
#  iapp_service_name: $iapp_name
  ve_instance: 1.2.3.4
#  bigip_un: admin
#  bigip_pw: admin
DEFAULT_PARAMS
    
    my $params= $default_params;
    
    foreach $vartype (sort @vartypes) {
	
	foreach $v (sort @$vartype) {
	    
	    $v_name= $v;
	    $v_name=~ s/__(.*)__/$1/;
	    
	    $params= $params . "  " . $v_name . ":\n";
	    
            $_= $v_name;
            if (/^pm__/) { # Special processing for pool members
		
		$v_name_properties= $v_name . "_properties";
		$params= $params . "  " . $v_name_properties . ":\n";
            }

	    if (defined($imports{$v})) { # Special processing for imported objects
		$v_name_import= $v_name . "_import";
		$params= $params . "  " . $v_name_import . ":\n";
            }

	    
	}
    }
    
    return $params;
}


### The next functions are for the ansible-create option

sub ansible_create {
    
    # Ansible output file
    $ansible_filename= $t2i;
    $ansible_filename=~ s/\.t2i$/\.yaml/;
    
    open ANSIBLE, ">", $ansible_filename
        or die "Can't open file where the Ansible playbook would be written ($ansible_filename): $!";
    
    print ANSIBLE ansible_head();
    print ANSIBLE ansible_iapp_variables();
    
    close ANSIBLE
        or die "Couldn't close the file for the Ansible playbook ($ansible_filename): $!";
    
    print "Written the resulting Ansible playbook $ansible_filename\n";
}

sub ansible_head {
    
    my $head = << "HEAD";

---
- hosts: <fill with target BIG-IP>
  tasks:
   - name: Add to the BIG-IP library the iApp file $iapp_name.tmpl
     delegate_to: localhost
     bigip_iapp_template:
       content: "{{ lookup('template', '$iapp_name.tmpl') }}"
       # force: <true|false>
       server: <fill with the DNS name/IP of the target BIG-IP>
       user: <fill with the appropiate admin user>
       password: <fill with admin user's password>
       state: "present"
   - name: Deploy the iApp $iapp_name
     delegate_to: localhost
     bigip_iapp_service:
       name: <fill with the name of the name of the service instance>
       template: $iapp_name
       # force: <true|false>
       server: <fill with the DNS name/IP of the target BIG-IP>
       user: <fill with the appropiate admin user>
       password: <fill with admin user's password>
       state: "present"
HEAD
    
    return $head;
}

sub ansible_iapp_variables{
    
    $vars_count= 0;
    
    foreach $vartype (sort @vartypes) {
	
	@v= $vartype;
	$vars_count+= $#v +1;
    }
    
    if ($vars_count == 0) {
	return "";
    }
    
    my $section= << "VARIABLES";
       parameters:
         variables:
VARIABLES

    $vartype_plain= 1;
    
    foreach $vartype (sort @vartypes) {
	
	# we append a var__ prefix if it is plain var type
	if ($vartype_plain == 1) {
	    $prefix= "var__";
	    $vartype_plain= 0;
	} else {
	    $prefix= "";
	}
	
	foreach $v (sort @$vartype) {
	    
	    $v_name= $v;
	    $v_name=~ s/__(.*)__/$1/;
	    $v_name= $prefix . $v_name;
	    
	    $section.= "            - name: \"$v_name\"\n";
	    $section.= "              value: \"<fill me>\"\n";
	    
            $_= $v_name;
            if (/^pm__/) { # Special handling for pool members
		
		$v_name_properties= $v_name . "_properties";
		$section.= "            - name: \"$v_name_properties\"\n";
		$section.= "              value: \"<fill me>\"\n";
            }

	    if (defined($imports{$v})) { # Special processing for imported objects
		$v_name_import= $v_name . "_import";
		$section.= "            - name: \"$v_name_import\"\n";
		$section.= "              value: \"<fill me>\"\n";
            }
	    
	}
    }
    
    return $section;
}

### The next functions are for the iworkflow-json-apl option

sub variable_is_required {
    my $vname= $_[0];

    if (defined($properties{$vname})) {
        $_= $properties{$vname};

        if (/(^|\s+)required($|\s+)/) {
             return "true";
        }
    }

    return "false"; 
}

sub iworkflow_json_apl {
    
    my $create_file= $_[0];
    
    if ($create_file) {
	
	open APL, ">", $apl_filename
 	    or die "Can't open file where the APL json would be written ($apl_filename): $!";
    }
    
    my $json= { };
    my $i= 0; # iterates on the JSON elements
    my $j= 0; # iterates on the variable type descriptions

    foreach $vartype (sort @vartypes) {

        @vt= @$vartype;

        if (($#vt +1) > 0) {

            $_= $vt[0];

            # vt_name = variable type name
            if (/__(.+)__(.+)__/) {
                $vt_name= $1; # non plain variables type
            } else {
                $vt_name= "var"; # plain variables type
            }

            $json->{'sections'}->[$i]->{'description'}= $vartypes_desc[$j];
            $json->{'sections'}->[$i]->{'displayName'}= $vt_name;

	    $i= $i +1;
	}

        $j= $j +1;
    }

    my $vartype_plain= 1;
    $i= 0;

    foreach $vartype (sort @vartypes) {

        @vt= @$vartype;

        if (($#vt +1) > 0) {

            $_= $vt[0];

            # vt_name = variable type name
            if (/__(.+)__(.+)__/) {
                $vt_name= $1; # non plain variables type
            } else {
                $vt_name= "var"; # plain variables type
            }

            foreach $v (sort @$vartype) {
                
                $vname= $v;
		
                if (defined($labels{$vname})) {
                    $label= "$labels{$vname}";
                } else {

                    # we append a __var prefix if it is plain var type
                    if ($vartype_plain == 1) {
                        $prefix= "__var";
                    } else {
                        $prefix= "";
                    }

                    $label= $prefix . $vname;
                }

                $short_vname= $vname;
                $short_vname=~ s/__(.*__|)(.+)__/$2/;

                $json->{'vars'}->[$i]->{name}= $short_vname;
                $json->{'vars'}->[$i]->{isRequired}= variable_is_required($vname);
                $json->{'vars'}->[$i]->{description}= "$label";
                $json->{'vars'}->[$i]->{displayName}= "$label";
                $json->{'vars'}->[$i]->{section}= $vt_name;

                $i= $i +1;

                if ($vt_name eq "pm") {

		    $short_vname_properties= $short_vname . "_properties";

		    $json->{'vars'}->[$i]->{name}= $short_vname_properties;
		    $json->{'vars'}->[$i]->{isRequired}= variable_is_required($vname);
		    $json->{'vars'}->[$i]->{description}= "Properties for " . "$label";
		    $json->{'vars'}->[$i]->{displayName}= "Properties for " . "$label";
		    $json->{'vars'}->[$i]->{section}= $vt_name;
		    
		    $i= $i +1;
                }

		if (defined($imports{$v})) { # Special processing for imported objects
		    $short_vname_import= $short_vname . "_import";

		    $json->{'vars'}->[$i]->{name}= $short_vname_import;
		    $json->{'vars'}->[$i]->{isRequired}= variable_is_required($vname);
		    $json->{'vars'}->[$i]->{description}= "URL for " . "$label";
		    $json->{'vars'}->[$i]->{displayName}= "URL for " . "$label";
		    $json->{'vars'}->[$i]->{section}= $vt_name;
		    
		    $i= $i +1;
                }
		
            }
        }

        $vartype_plain= 0;
    }


    if ($create_file) {

        my $json_text = to_json($json, {utf8 => 1, pretty => 1});

        print APL $json_text;

        close APL
	    or die "Couldn't close the file for the APL json ($apl_filename): $!";
	
        print "Written the resulting APL json to $apl_filename\n";
    } else {
	return $json;
    }
}

sub iworkflow_json_import {

    open IMPORT, ">", $import_filename
	or die "Can't open file where the IMPORT json would be written ($import_filename): $!";
    
    my $json= { };

    $json->{'name'}= $iapp_name;

    open IAPP, "<", $iapp_filename
	or die "Can't open file of the iApp ($iapp_filename). This file has to be generated previously: $!";
    $json->{'templateContent'}= do { local $/; <IAPP> };
    close IAPP;

    if (defined($iapp{"requires-bigip-version-min"})) {
	$json->{'minSupportedBIGIPVersion'}= $iapp{"requires-bigip-version-min"};
    }
    if (defined($iapp{"requires-bigip-version-max"})) {
	$json->{'maxSupportedBIGIPVersion'}= $iapp{"requires-bigip-version-max"};
    }
    if (defined($iapp{"unsupported-bigip-versions"})) {
        $json->{'unsupportedBIGIPVersions'}= from_json($iapp{"unsupported-bigip-versions"});
    }
    $json->{'template'}= iworkflow_json_apl(0);

    my $json_text = to_json($json, {utf8 => 1, pretty => 1});

    print IMPORT $json_text;

    close IMPORT
	or die "Couldn't close the file for the IMPORT json ($import_filename): $!";

    print "Written the resulting IMPORT json to $import_filename\n";

}

sub check_variable_names() {

    my @variables = @{$_[0]};

    if (grep(/-/, @variables)) {

	print STDERR "Aborting: found variables that have hyphen in their name and iApps don't support these. Please rename the following variables: ";

	foreach $v (sort @variables) {
	    
	    $_= $v;
	    if (/-/) {
	    
		print STDERR "$v ";
	    }
	}
	
	print STDERR "\n";

	exit(1);
    }
    
}

sub check_iworkflow_variables() {
    
    my @v = @{$_[0]};
    
    if (($#v == 1) || ($#v == -1)) { # or we have the two expected variables or we have none
	return 0;
    }

    print STDERR "Aborting: when using iWorkflow's variables both __pool__port__ and __pool__addr__ must be defined. Showing the variables found: ";

    foreach $i (sort @v) {	
      	print STDERR "$i ";
    }
    
    print STDERR "\n";

    exit(1);
}

####################################################################################
# Functions for t2i generation

sub check_this_is_bigip {

    if (( -r "/config/bigip.conf") && ( -r "/config/bigip_base.conf" )) {
	return 1;
    }

    return 0;
}

sub make_snapshot {
    my $snapshot= $_[0];

    system("mkdir -p $cfgdir/tmsh2iapp.$snapshot && cp /config/bigip.conf /config/bigip_base.conf $cfgdir/tmsh2iapp.$snapshot");
    
    if ( $? == -1 ) {
	die "Error while trying to make snapshot $snapshot: $!";
    }

    print "Created snapshot of configuration files in folder $cfgdir/tmsh2iapp.$snapshot\n";
}

sub diff_snapshots {

    my $snapshot1= $_[0];
    my $snapshot2= $_[1];

    open(DIFF, "diff -ur $cfgdir/tmsh2iapp.$snapshot1 $cfgdir/tmsh2iapp.$snapshot2 | egrep '^\\+\\+\\+' | wc -l |") || die "Could not geneterate the baseline .t2i (when running first diff command): $!\n";
    $changed= do { local $/; <DIFF> };
    close(DIFF);
    
    if ($changed == 0) {
	print STDERR "There are no differences between snapshot $snapshot1 and $snapshot2\n";
	exit(1);
    } elsif ($changed == 2) {
	print STDERR "Warning: Both bigip.conf and bigip_base.conf differ in snapshots $snapshot1 and $snapshot2. An iApp should contain either local of cluster-wide objects but not both\n";
    }

    # We also remove some basic stuff like the app-service field
    open(DIFF, "diff -ur $cfgdir/tmsh2iapp.$snapshot1 $cfgdir/tmsh2iapp.$snapshot2 | egrep '^\\+' | grep -v app-service | egrep -v '^\\+\\+\\+' | cut -c 2- |") || die "Could not geneterate the baseline .t2i (when running the second diff command): $!";

    $baseline= do { local $/; <DIFF> };
    $baseline=~ s/\/Common\///g;
    close DIFF;

    $output= $cfgdir . "/" . "tmsh2iapp-" . $snapshot1 . "-" . $snapshot2 . ".t2i";
    open(OUTPUT, ">", $output) || die "Could not geneterate the baseline file $output: $!";

    do { 
        local $/; 
        print OUTPUT $baseline;
    };

    close OUTPUT;

    print "Written the resulting baseline file to $output\n";
}

####################################################################################
# BIG-IP object import functions

# Instantiates perl arrays for import types with the the iApp variables in their contents, one array per type

sub attribute_import_type {

    my $import_otype= $_[0]; # original type name
    my $import_type= $import_otype;
    $import_type=~ s/-/_/g; # the perl variables are the same as tmsh but we replace "-" with "_";
    my $value= $_[1];
    
    if (!grep( /^$import_otype$/, @import_file_types)) {
	print STDERR "Aborting due to unknown \@import of \"$import_otype\" in the t2i template. Check the name is correct.\n";
	exit(1);
    }
    
    if (@$import_type) {
	print STDERR "Aborting due to \"$import_otype\" already defined as \@import. Pleasse correct the .t2i file.\n";
	exit(1);
    }
    
    @$import_type= split /\s+/, $value; # we assign the values into an array of each type, ie: ssl_cert[0]= __var_name_1__ ...
    
    foreach $var (sort @$import_type) {
	
	$imports{$var}= "true"; # This hash defines all variables that have an import regardless of the type
	
	if (!grep(/^$var$/, @variables)) {
	    
	    print STDERR "Error while trying to import $import_otype: there is no variable named $var in the .t2i file. Check that the name is correct.\n";
	    exit(1);
	}
	
	if ($import_type eq "data_group") { # We do additional checking for data-groups
	    
	    if (!defined($properties{$var})) {
		
		print STDERR "Aborting due to \@properties for import data-group variable $var not being defined before the \@import of the variable. Put the \@properties at the top of the .t2i file.\n";
		exit(1);
	    }
	    
	    $_= $properties{$var};
	    
	    if (!/type\s+(string|integer|ip)/) {
		
		print STDERR "Aborting due to \@properties for import data-group variable $var doesn't have the type indicated. Possible options are:\n";
		print STDERR "type string\n";
		print STDERR "type integer\n";
		print STDERR "type ip\n\n";
		print STDERR "Check the tmsh2iapp documentation for more information.\n";
		exit(1);
	    }
	}
    }
}


####################################################################################
# Generic functions

sub uniq {
    my %seen;
    return grep { !$seen{$_}++ } @_;
}

sub print_version {

    print "$tmsh2iapp_version\n";
}

sub check_legacy_properties_usage {

    $v_name= $_[0];
    $v_value= $_[1];

    $_= $v_value;

    if (/default|display|required|validator/) {

	print STDERR "Aborting: \@properties attribute for variable \"$v_name\" is using legacy APL values: \"$v_value\"\n";
	print STDERR "You have two options:\n";
	print STDERR "- Use a version of tmsh2iapp earlier than 20170627.1\n";
	print STDERR "- Rename \@properties to \@apl in the .t2i file (recommended option)\n";

	exit(1);
    }
}

sub print_synopsis {

    my $synopsis= << "SYNOPSIS";

Synopsis:

- iApp creation: tmsh2iapp.pl (service|service-disable-strict-updates|common|common-disable-strict-updates|system) <template file with .t2i extension>

- Heat template: tmsh2iapp.pl heat-create <template file with .t2i extension>

- Ansible playbook: tmsh2iapp.pl ansible-create <template file with .t2i extension>

- iWorkflow JSON files: tmsh2iapp.pl (iworkflow-template-import|iworkflow-json-apl) <template file with .t2i extension>

- For creating a baseline .t2i file: 

   tmsh2iapp.pl snapshot-create <name of the snapshot>
   tmsh2iapp.pl t2i-create <name of snapshot #1> <name of snapshot #2>

Additional information:

- For more information on using this tool: tmsh2iapp.pl usage

- For version information of this tool: tmsh2iapp.pl version

SYNOPSIS

    print STDERR $synopsis;
}


sub print_usage {

    my $description= << "DESCRIPTION";

tmsh2iapp creates an iAPP from a TMSH-like template. The resulting iApp is written to a file with the same name but .tmpl extension.

This utility can also create helper files to use the resulting iApp in orchestration systems (Heat/Ansible/iWorkflow).

DESCRIPTION

    print STDERR $description;

    print_synopsis();

    my $details= <<"DETAILS";

Details: 

  + Parameters for iApp creation:

       service - Indicates that on iApp instantiation the configuration will be contained in it's own iApp folder (most common case).
       service-disable-strict-updates - Like "service" but allows the iApp generated configuration to be modified from outside the iApp.
       common - Indicates that on iApp instantiation the configuration will be placed in the /Common folder.
       common-disable-strict-updates - Like "common" but allows the iApp generated configuration to be modified from outside the iApp.
       system - Indicates that on iApp instantiation the configuration will be contained in the / folder.

  + Parameters for HEAT template creation:

       heat-create - Creates HEAT parameters (.parameters) and HEAT template (.yaml) files to load the iApp and instantiate it in Openstack.

  + Parameters for Ansible playbook creation:

       ansible-create - Creates a template Ansible playbook (.yaml) to ease deploying the iApp with Ansible.

  + Parameters for iWorkflow:

       iworkflow-template-import - Create a compound JSON file that incorporates iApp, APL and other bits to allow single file import via REST or GUI. This command requires the iApp .tmpl file to be present in the same folder as the .t2i. This JSON file doesn't incoporate the Service Tier information. This will be implemented with service templates.
       iworkflow-json-apl - Only create the APL JSON file.

       Note: At the moment tmsh2iapp doesn't feature creating service templates and service instances JSON files.

   + Parameters for creating a baseline .t2i file (these are expected to be run in a BIG-IP):
      
       snapshot-create - Copies bigip.conf and bigip.conf in a snapshot folder (specified as parameter) located in $cfgdir
       t2i-create - Compares two snapshot folders and produces a baseline .t2i file in $cfgdir

DETAILS

    print STDERR $details;
}

